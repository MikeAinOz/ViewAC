{"mappings":"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","sources":["./node_modules/antlr4ts/atn/ProfilingATNSimulator.js","./node_modules/antlr4ts/atn/AmbiguityInfo.js","./node_modules/antlr4ts/atn/DecisionEventInfo.js","./node_modules/antlr4ts/atn/ContextSensitivityInfo.js","./node_modules/antlr4ts/atn/DecisionInfo.js","./node_modules/antlr4ts/atn/ErrorInfo.js","./node_modules/antlr4ts/atn/LookaheadEventInfo.js","./node_modules/antlr4ts/atn/PredicateEvalInfo.js"],"sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// ConvertTo-TS run at 2016-10-04T11:26:36.4188352-07:00\r\nconst AmbiguityInfo_1 = require(\"./AmbiguityInfo\");\r\nconst ATN_1 = require(\"./ATN\");\r\nconst ATNSimulator_1 = require(\"./ATNSimulator\");\r\nconst ContextSensitivityInfo_1 = require(\"./ContextSensitivityInfo\");\r\nconst DecisionInfo_1 = require(\"./DecisionInfo\");\r\nconst ErrorInfo_1 = require(\"./ErrorInfo\");\r\nconst Decorators_1 = require(\"../Decorators\");\r\nconst LookaheadEventInfo_1 = require(\"./LookaheadEventInfo\");\r\nconst ParserATNSimulator_1 = require(\"./ParserATNSimulator\");\r\nconst PredicateEvalInfo_1 = require(\"./PredicateEvalInfo\");\r\nconst SemanticContext_1 = require(\"./SemanticContext\");\r\nconst SimulatorState_1 = require(\"./SimulatorState\");\r\n/**\r\n * @since 4.3\r\n */\r\nclass ProfilingATNSimulator extends ParserATNSimulator_1.ParserATNSimulator {\r\n    constructor(parser) {\r\n        super(parser.interpreter.atn, parser);\r\n        this._startIndex = 0;\r\n        this._sllStopIndex = 0;\r\n        this._llStopIndex = 0;\r\n        this.currentDecision = 0;\r\n        /** At the point of LL failover, we record how SLL would resolve the conflict so that\r\n         *  we can determine whether or not a decision / input pair is context-sensitive.\r\n         *  If LL gives a different result than SLL's predicted alternative, we have a\r\n         *  context sensitivity for sure. The converse is not necessarily true, however.\r\n         *  It's possible that after conflict resolution chooses minimum alternatives,\r\n         *  SLL could get the same answer as LL. Regardless of whether or not the result indicates\r\n         *  an ambiguity, it is not treated as a context sensitivity because LL prediction\r\n         *  was not required in order to produce a correct prediction for this decision and input sequence.\r\n         *  It may in fact still be a context sensitivity but we don't know by looking at the\r\n         *  minimum alternatives for the current input.\r\n         */\r\n        this.conflictingAltResolvedBySLL = 0;\r\n        this.optimize_ll1 = false;\r\n        this.reportAmbiguities = true;\r\n        this.numDecisions = this.atn.decisionToState.length;\r\n        this.decisions = [];\r\n        for (let i = 0; i < this.numDecisions; i++) {\r\n            this.decisions.push(new DecisionInfo_1.DecisionInfo(i));\r\n        }\r\n    }\r\n    adaptivePredict(input, decision, outerContext, useContext) {\r\n        if (useContext !== undefined) {\r\n            return super.adaptivePredict(input, decision, outerContext, useContext);\r\n        }\r\n        try {\r\n            this._input = input;\r\n            this._startIndex = input.index;\r\n            // it's possible for SLL to reach a conflict state without consuming any input\r\n            this._sllStopIndex = this._startIndex - 1;\r\n            this._llStopIndex = -1;\r\n            this.currentDecision = decision;\r\n            this.currentState = undefined;\r\n            this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;\r\n            let start = process.hrtime();\r\n            let alt = super.adaptivePredict(input, decision, outerContext);\r\n            let stop = process.hrtime();\r\n            let nanoseconds = (stop[0] - start[0]) * 1000000000;\r\n            if (nanoseconds === 0) {\r\n                nanoseconds = stop[1] - start[1];\r\n            }\r\n            else {\r\n                // Add nanoseconds from start to end of that second, plus start of the end second to end\r\n                nanoseconds += (1000000000 - start[1]) + stop[1];\r\n            }\r\n            this.decisions[decision].timeInPrediction += nanoseconds;\r\n            this.decisions[decision].invocations++;\r\n            let SLL_k = this._sllStopIndex - this._startIndex + 1;\r\n            this.decisions[decision].SLL_TotalLook += SLL_k;\r\n            this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);\r\n            if (SLL_k > this.decisions[decision].SLL_MaxLook) {\r\n                this.decisions[decision].SLL_MaxLook = SLL_k;\r\n                this.decisions[decision].SLL_MaxLookEvent =\r\n                    new LookaheadEventInfo_1.LookaheadEventInfo(decision, undefined, alt, input, this._startIndex, this._sllStopIndex, false);\r\n            }\r\n            if (this._llStopIndex >= 0) {\r\n                let LL_k = this._llStopIndex - this._startIndex + 1;\r\n                this.decisions[decision].LL_TotalLook += LL_k;\r\n                this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);\r\n                if (LL_k > this.decisions[decision].LL_MaxLook) {\r\n                    this.decisions[decision].LL_MaxLook = LL_k;\r\n                    this.decisions[decision].LL_MaxLookEvent =\r\n                        new LookaheadEventInfo_1.LookaheadEventInfo(decision, undefined, alt, input, this._startIndex, this._llStopIndex, true);\r\n                }\r\n            }\r\n            return alt;\r\n        }\r\n        finally {\r\n            this._input = undefined;\r\n            this.currentDecision = -1;\r\n        }\r\n    }\r\n    getStartState(dfa, input, outerContext, useContext) {\r\n        let state = super.getStartState(dfa, input, outerContext, useContext);\r\n        this.currentState = state;\r\n        return state;\r\n    }\r\n    computeStartState(dfa, globalContext, useContext) {\r\n        let state = super.computeStartState(dfa, globalContext, useContext);\r\n        this.currentState = state;\r\n        return state;\r\n    }\r\n    computeReachSet(dfa, previous, t, contextCache) {\r\n        if (this._input === undefined) {\r\n            throw new Error(\"Invalid state\");\r\n        }\r\n        let reachState = super.computeReachSet(dfa, previous, t, contextCache);\r\n        if (reachState == null) {\r\n            // no reach on current lookahead symbol. ERROR.\r\n            this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index));\r\n        }\r\n        this.currentState = reachState;\r\n        return reachState;\r\n    }\r\n    getExistingTargetState(previousD, t) {\r\n        if (this.currentState === undefined || this._input === undefined) {\r\n            throw new Error(\"Invalid state\");\r\n        }\r\n        // this method is called after each time the input position advances\r\n        if (this.currentState.useContext) {\r\n            this._llStopIndex = this._input.index;\r\n        }\r\n        else {\r\n            this._sllStopIndex = this._input.index;\r\n        }\r\n        let existingTargetState = super.getExistingTargetState(previousD, t);\r\n        if (existingTargetState != null) {\r\n            // this method is directly called by execDFA; must construct a SimulatorState\r\n            // to represent the current state for this case\r\n            this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);\r\n            if (this.currentState.useContext) {\r\n                this.decisions[this.currentDecision].LL_DFATransitions++;\r\n            }\r\n            else {\r\n                this.decisions[this.currentDecision].SLL_DFATransitions++; // count only if we transition over a DFA state\r\n            }\r\n            if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {\r\n                let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);\r\n                this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));\r\n            }\r\n        }\r\n        return existingTargetState;\r\n    }\r\n    computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {\r\n        let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);\r\n        if (useContext) {\r\n            this.decisions[this.currentDecision].LL_ATNTransitions++;\r\n        }\r\n        else {\r\n            this.decisions[this.currentDecision].SLL_ATNTransitions++;\r\n        }\r\n        return targetState;\r\n    }\r\n    evalSemanticContextImpl(pred, parserCallStack, alt) {\r\n        if (this.currentState === undefined || this._input === undefined) {\r\n            throw new Error(\"Invalid state\");\r\n        }\r\n        let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);\r\n        if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {\r\n            let fullContext = this._llStopIndex >= 0;\r\n            let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;\r\n            this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));\r\n        }\r\n        return result;\r\n    }\r\n    reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {\r\n        if (this._input === undefined) {\r\n            throw new Error(\"Invalid state\");\r\n        }\r\n        if (prediction !== this.conflictingAltResolvedBySLL) {\r\n            this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));\r\n        }\r\n        super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);\r\n    }\r\n    reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {\r\n        if (conflictingAlts != null) {\r\n            this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);\r\n        }\r\n        else {\r\n            this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);\r\n        }\r\n        this.decisions[this.currentDecision].LL_Fallback++;\r\n        super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);\r\n    }\r\n    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {\r\n        if (this.currentState === undefined || this._input === undefined) {\r\n            throw new Error(\"Invalid state\");\r\n        }\r\n        let prediction;\r\n        if (ambigAlts != null) {\r\n            prediction = ambigAlts.nextSetBit(0);\r\n        }\r\n        else {\r\n            prediction = configs.getRepresentedAlternatives().nextSetBit(0);\r\n        }\r\n        if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {\r\n            // Even though this is an ambiguity we are reporting, we can\r\n            // still detect some context sensitivities.  Both SLL and LL\r\n            // are showing a conflict, hence an ambiguity, but if they resolve\r\n            // to different minimum alternatives we have also identified a\r\n            // context sensitivity.\r\n            this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));\r\n        }\r\n        this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));\r\n        super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);\r\n    }\r\n    // ---------------------------------------------------------------------\r\n    getDecisionInfo() {\r\n        return this.decisions;\r\n    }\r\n    getCurrentState() {\r\n        return this.currentState;\r\n    }\r\n}\r\n__decorate([\r\n    Decorators_1.Override,\r\n    __param(0, Decorators_1.NotNull)\r\n], ProfilingATNSimulator.prototype, \"adaptivePredict\", null);\r\n__decorate([\r\n    Decorators_1.Override\r\n], ProfilingATNSimulator.prototype, \"getStartState\", null);\r\n__decorate([\r\n    Decorators_1.Override\r\n], ProfilingATNSimulator.prototype, \"computeStartState\", null);\r\n__decorate([\r\n    Decorators_1.Override\r\n], ProfilingATNSimulator.prototype, \"computeReachSet\", null);\r\n__decorate([\r\n    Decorators_1.Override\r\n], ProfilingATNSimulator.prototype, \"getExistingTargetState\", null);\r\n__decorate([\r\n    Decorators_1.Override\r\n], ProfilingATNSimulator.prototype, \"computeTargetState\", null);\r\n__decorate([\r\n    Decorators_1.Override\r\n], ProfilingATNSimulator.prototype, \"evalSemanticContextImpl\", null);\r\n__decorate([\r\n    Decorators_1.Override\r\n], ProfilingATNSimulator.prototype, \"reportContextSensitivity\", null);\r\n__decorate([\r\n    Decorators_1.Override\r\n], ProfilingATNSimulator.prototype, \"reportAttemptingFullContext\", null);\r\n__decorate([\r\n    Decorators_1.Override,\r\n    __param(0, Decorators_1.NotNull), __param(5, Decorators_1.NotNull), __param(6, Decorators_1.NotNull)\r\n], ProfilingATNSimulator.prototype, \"reportAmbiguity\", null);\r\nexports.ProfilingATNSimulator = ProfilingATNSimulator;\r\n//# sourceMappingURL=ProfilingATNSimulator.js.map","\"use strict\";\r\n/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DecisionEventInfo_1 = require(\"./DecisionEventInfo\");\r\nconst Decorators_1 = require(\"../Decorators\");\r\n/**\r\n * This class represents profiling event information for an ambiguity.\r\n * Ambiguities are decisions where a particular input resulted in an SLL\r\n * conflict, followed by LL prediction also reaching a conflict state\r\n * (indicating a true ambiguity in the grammar).\r\n *\r\n * This event may be reported during SLL prediction in cases where the\r\n * conflicting SLL configuration set provides sufficient information to\r\n * determine that the SLL conflict is truly an ambiguity. For example, if none\r\n * of the ATN configurations in the conflicting SLL configuration set have\r\n * traversed a global follow transition (i.e.\r\n * {@link ATNConfig#getReachesIntoOuterContext} is `false` for all\r\n * configurations), then the result of SLL prediction for that input is known to\r\n * be equivalent to the result of LL prediction for that input.\r\n *\r\n * In some cases, the minimum represented alternative in the conflicting LL\r\n * configuration set is not equal to the minimum represented alternative in the\r\n * conflicting SLL configuration set. Grammars and inputs which result in this\r\n * scenario are unable to use {@link PredictionMode#SLL}, which in turn means\r\n * they cannot use the two-stage parsing strategy to improve parsing performance\r\n * for that input.\r\n *\r\n * @see ParserATNSimulator#reportAmbiguity\r\n * @see ParserErrorListener#reportAmbiguity\r\n *\r\n * @since 4.3\r\n */\r\nlet AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {\r\n    /**\r\n     * Constructs a new instance of the {@link AmbiguityInfo} class with the\r\n     * specified detailed ambiguity information.\r\n     *\r\n     * @param decision The decision number\r\n     * @param state The final simulator state identifying the ambiguous\r\n     * alternatives for the current input\r\n     * @param ambigAlts The set of alternatives in the decision that lead to a valid parse.\r\n     *                  The predicted alt is the min(ambigAlts)\r\n     * @param input The input token stream\r\n     * @param startIndex The start index for the current prediction\r\n     * @param stopIndex The index at which the ambiguity was identified during\r\n     * prediction\r\n     */\r\n    constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {\r\n        super(decision, state, input, startIndex, stopIndex, state.useContext);\r\n        this.ambigAlts = ambigAlts;\r\n    }\r\n    /**\r\n     * Gets the set of alternatives in the decision that lead to a valid parse.\r\n     *\r\n     * @since 4.5\r\n     */\r\n    get ambiguousAlternatives() {\r\n        return this.ambigAlts;\r\n    }\r\n};\r\n__decorate([\r\n    Decorators_1.NotNull\r\n], AmbiguityInfo.prototype, \"ambigAlts\", void 0);\r\n__decorate([\r\n    Decorators_1.NotNull\r\n], AmbiguityInfo.prototype, \"ambiguousAlternatives\", null);\r\nAmbiguityInfo = __decorate([\r\n    __param(1, Decorators_1.NotNull),\r\n    __param(2, Decorators_1.NotNull),\r\n    __param(3, Decorators_1.NotNull)\r\n], AmbiguityInfo);\r\nexports.AmbiguityInfo = AmbiguityInfo;\r\n//# sourceMappingURL=AmbiguityInfo.js.map","\"use strict\";\r\n/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.2401032-07:00\r\nconst Decorators_1 = require(\"../Decorators\");\r\n/**\r\n * This is the base class for gathering detailed information about prediction\r\n * events which occur during parsing.\r\n *\r\n * Note that we could record the parser call stack at the time this event\r\n * occurred but in the presence of left recursive rules, the stack is kind of\r\n * meaningless. It's better to look at the individual configurations for their\r\n * individual stacks. Of course that is a {@link PredictionContext} object\r\n * not a parse tree node and so it does not have information about the extent\r\n * (start...stop) of the various subtrees. Examining the stack tops of all\r\n * configurations provide the return states for the rule invocations.\r\n * From there you can get the enclosing rule.\r\n *\r\n * @since 4.3\r\n */\r\nlet DecisionEventInfo = class DecisionEventInfo {\r\n    constructor(decision, state, input, startIndex, stopIndex, fullCtx) {\r\n        this.decision = decision;\r\n        this.fullCtx = fullCtx;\r\n        this.stopIndex = stopIndex;\r\n        this.input = input;\r\n        this.startIndex = startIndex;\r\n        this.state = state;\r\n    }\r\n};\r\n__decorate([\r\n    Decorators_1.NotNull\r\n], DecisionEventInfo.prototype, \"input\", void 0);\r\nDecisionEventInfo = __decorate([\r\n    __param(2, Decorators_1.NotNull)\r\n], DecisionEventInfo);\r\nexports.DecisionEventInfo = DecisionEventInfo;\r\n//# sourceMappingURL=DecisionEventInfo.js.map","\"use strict\";\r\n/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.1575933-07:00\r\nconst DecisionEventInfo_1 = require(\"./DecisionEventInfo\");\r\nconst Decorators_1 = require(\"../Decorators\");\r\n/**\r\n * This class represents profiling event information for a context sensitivity.\r\n * Context sensitivities are decisions where a particular input resulted in an\r\n * SLL conflict, but LL prediction produced a single unique alternative.\r\n *\r\n * In some cases, the unique alternative identified by LL prediction is not\r\n * equal to the minimum represented alternative in the conflicting SLL\r\n * configuration set. Grammars and inputs which result in this scenario are\r\n * unable to use {@link PredictionMode#SLL}, which in turn means they cannot use\r\n * the two-stage parsing strategy to improve parsing performance for that\r\n * input.\r\n *\r\n * @see ParserATNSimulator#reportContextSensitivity\r\n * @see ParserErrorListener#reportContextSensitivity\r\n *\r\n * @since 4.3\r\n */\r\nlet ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {\r\n    /**\r\n     * Constructs a new instance of the {@link ContextSensitivityInfo} class\r\n     * with the specified detailed context sensitivity information.\r\n     *\r\n     * @param decision The decision number\r\n     * @param state The final simulator state containing the unique\r\n     * alternative identified by full-context prediction\r\n     * @param input The input token stream\r\n     * @param startIndex The start index for the current prediction\r\n     * @param stopIndex The index at which the context sensitivity was\r\n     * identified during full-context prediction\r\n     */\r\n    constructor(decision, state, input, startIndex, stopIndex) {\r\n        super(decision, state, input, startIndex, stopIndex, true);\r\n    }\r\n};\r\nContextSensitivityInfo = __decorate([\r\n    __param(1, Decorators_1.NotNull),\r\n    __param(2, Decorators_1.NotNull)\r\n], ContextSensitivityInfo);\r\nexports.ContextSensitivityInfo = ContextSensitivityInfo;\r\n//# sourceMappingURL=ContextSensitivityInfo.js.map","\"use strict\";\r\n/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Decorators_1 = require(\"../Decorators\");\r\n/**\r\n * This class contains profiling gathered for a particular decision.\r\n *\r\n * Parsing performance in ANTLR 4 is heavily influenced by both static factors\r\n * (e.g. the form of the rules in the grammar) and dynamic factors (e.g. the\r\n * choice of input and the state of the DFA cache at the time profiling\r\n * operations are started). For best results, gather and use aggregate\r\n * statistics from a large sample of inputs representing the inputs expected in\r\n * production before using the results to make changes in the grammar.\r\n *\r\n * @since 4.3\r\n */\r\nclass DecisionInfo {\r\n    /**\r\n     * Constructs a new instance of the {@link DecisionInfo} class to contain\r\n     * statistics for a particular decision.\r\n     *\r\n     * @param decision The decision number\r\n     */\r\n    constructor(decision) {\r\n        /**\r\n         * The total number of times {@link ParserATNSimulator#adaptivePredict} was\r\n         * invoked for this decision.\r\n         */\r\n        this.invocations = 0;\r\n        /**\r\n         * The total time spent in {@link ParserATNSimulator#adaptivePredict} for\r\n         * this decision, in nanoseconds.\r\n         *\r\n         * The value of this field contains the sum of differential results obtained\r\n         * by {@link System#nanoTime()}, and is not adjusted to compensate for JIT\r\n         * and/or garbage collection overhead. For best accuracy, use a modern JVM\r\n         * implementation that provides precise results from\r\n         * {@link System#nanoTime()}, and perform profiling in a separate process\r\n         * which is warmed up by parsing the input prior to profiling. If desired,\r\n         * call {@link ATNSimulator#clearDFA} to reset the DFA cache to its initial\r\n         * state before starting the profiling measurement pass.\r\n         */\r\n        this.timeInPrediction = 0;\r\n        /**\r\n         * The sum of the lookahead required for SLL prediction for this decision.\r\n         * Note that SLL prediction is used before LL prediction for performance\r\n         * reasons even when {@link PredictionMode#LL} or\r\n         * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.\r\n         */\r\n        this.SLL_TotalLook = 0;\r\n        /**\r\n         * Gets the minimum lookahead required for any single SLL prediction to\r\n         * complete for this decision, by reaching a unique prediction, reaching an\r\n         * SLL conflict state, or encountering a syntax error.\r\n         */\r\n        this.SLL_MinLook = 0;\r\n        /**\r\n         * Gets the maximum lookahead required for any single SLL prediction to\r\n         * complete for this decision, by reaching a unique prediction, reaching an\r\n         * SLL conflict state, or encountering a syntax error.\r\n         */\r\n        this.SLL_MaxLook = 0;\r\n        /**\r\n         * The sum of the lookahead required for LL prediction for this decision.\r\n         * Note that LL prediction is only used when SLL prediction reaches a\r\n         * conflict state.\r\n         */\r\n        this.LL_TotalLook = 0;\r\n        /**\r\n         * Gets the minimum lookahead required for any single LL prediction to\r\n         * complete for this decision. An LL prediction completes when the algorithm\r\n         * reaches a unique prediction, a conflict state (for\r\n         * {@link PredictionMode#LL}, an ambiguity state (for\r\n         * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\r\n         */\r\n        this.LL_MinLook = 0;\r\n        /**\r\n         * Gets the maximum lookahead required for any single LL prediction to\r\n         * complete for this decision. An LL prediction completes when the algorithm\r\n         * reaches a unique prediction, a conflict state (for\r\n         * {@link PredictionMode#LL}, an ambiguity state (for\r\n         * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\r\n         */\r\n        this.LL_MaxLook = 0;\r\n        /**\r\n         * A collection of {@link ContextSensitivityInfo} instances describing the\r\n         * context sensitivities encountered during LL prediction for this decision.\r\n         *\r\n         * @see ContextSensitivityInfo\r\n         */\r\n        this.contextSensitivities = [];\r\n        /**\r\n         * A collection of {@link ErrorInfo} instances describing the parse errors\r\n         * identified during calls to {@link ParserATNSimulator#adaptivePredict} for\r\n         * this decision.\r\n         *\r\n         * @see ErrorInfo\r\n         */\r\n        this.errors = [];\r\n        /**\r\n         * A collection of {@link AmbiguityInfo} instances describing the\r\n         * ambiguities encountered during LL prediction for this decision.\r\n         *\r\n         * @see AmbiguityInfo\r\n         */\r\n        this.ambiguities = [];\r\n        /**\r\n         * A collection of {@link PredicateEvalInfo} instances describing the\r\n         * results of evaluating individual predicates during prediction for this\r\n         * decision.\r\n         *\r\n         * @see PredicateEvalInfo\r\n         */\r\n        this.predicateEvals = [];\r\n        /**\r\n         * The total number of ATN transitions required during SLL prediction for\r\n         * this decision. An ATN transition is determined by the number of times the\r\n         * DFA does not contain an edge that is required for prediction, resulting\r\n         * in on-the-fly computation of that edge.\r\n         *\r\n         * If DFA caching of SLL transitions is employed by the implementation, ATN\r\n         * computation may cache the computed edge for efficient lookup during\r\n         * future parsing of this decision. Otherwise, the SLL parsing algorithm\r\n         * will use ATN transitions exclusively.\r\n         *\r\n         * @see #SLL_ATNTransitions\r\n         * @see ParserATNSimulator#computeTargetState\r\n         * @see LexerATNSimulator#computeTargetState\r\n         */\r\n        this.SLL_ATNTransitions = 0;\r\n        /**\r\n         * The total number of DFA transitions required during SLL prediction for\r\n         * this decision.\r\n         *\r\n         * If the ATN simulator implementation does not use DFA caching for SLL\r\n         * transitions, this value will be 0.\r\n         *\r\n         * @see ParserATNSimulator#getExistingTargetState\r\n         * @see LexerATNSimulator#getExistingTargetState\r\n         */\r\n        this.SLL_DFATransitions = 0;\r\n        /**\r\n         * Gets the total number of times SLL prediction completed in a conflict\r\n         * state, resulting in fallback to LL prediction.\r\n         *\r\n         * Note that this value is not related to whether or not\r\n         * {@link PredictionMode#SLL} may be used successfully with a particular\r\n         * grammar. If the ambiguity resolution algorithm applied to the SLL\r\n         * conflicts for this decision produce the same result as LL prediction for\r\n         * this decision, {@link PredictionMode#SLL} would produce the same overall\r\n         * parsing result as {@link PredictionMode#LL}.\r\n         */\r\n        this.LL_Fallback = 0;\r\n        /**\r\n         * The total number of ATN transitions required during LL prediction for\r\n         * this decision. An ATN transition is determined by the number of times the\r\n         * DFA does not contain an edge that is required for prediction, resulting\r\n         * in on-the-fly computation of that edge.\r\n         *\r\n         * If DFA caching of LL transitions is employed by the implementation, ATN\r\n         * computation may cache the computed edge for efficient lookup during\r\n         * future parsing of this decision. Otherwise, the LL parsing algorithm will\r\n         * use ATN transitions exclusively.\r\n         *\r\n         * @see #LL_DFATransitions\r\n         * @see ParserATNSimulator#computeTargetState\r\n         * @see LexerATNSimulator#computeTargetState\r\n         */\r\n        this.LL_ATNTransitions = 0;\r\n        /**\r\n         * The total number of DFA transitions required during LL prediction for\r\n         * this decision.\r\n         *\r\n         * If the ATN simulator implementation does not use DFA caching for LL\r\n         * transitions, this value will be 0.\r\n         *\r\n         * @see ParserATNSimulator#getExistingTargetState\r\n         * @see LexerATNSimulator#getExistingTargetState\r\n         */\r\n        this.LL_DFATransitions = 0;\r\n        this.decision = decision;\r\n    }\r\n    toString() {\r\n        return \"{\" +\r\n            \"decision=\" + this.decision +\r\n            \", contextSensitivities=\" + this.contextSensitivities.length +\r\n            \", errors=\" + this.errors.length +\r\n            \", ambiguities=\" + this.ambiguities.length +\r\n            \", SLL_lookahead=\" + this.SLL_TotalLook +\r\n            \", SLL_ATNTransitions=\" + this.SLL_ATNTransitions +\r\n            \", SLL_DFATransitions=\" + this.SLL_DFATransitions +\r\n            \", LL_Fallback=\" + this.LL_Fallback +\r\n            \", LL_lookahead=\" + this.LL_TotalLook +\r\n            \", LL_ATNTransitions=\" + this.LL_ATNTransitions +\r\n            \"}\";\r\n    }\r\n}\r\n__decorate([\r\n    Decorators_1.Override\r\n], DecisionInfo.prototype, \"toString\", null);\r\nexports.DecisionInfo = DecisionInfo;\r\n//# sourceMappingURL=DecisionInfo.js.map","\"use strict\";\r\n/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.7213647-07:00\r\nconst DecisionEventInfo_1 = require(\"./DecisionEventInfo\");\r\nconst Decorators_1 = require(\"../Decorators\");\r\n/**\r\n * This class represents profiling event information for a syntax error\r\n * identified during prediction. Syntax errors occur when the prediction\r\n * algorithm is unable to identify an alternative which would lead to a\r\n * successful parse.\r\n *\r\n * @see Parser#notifyErrorListeners(Token, String, RecognitionException)\r\n * @see ANTLRErrorListener#syntaxError\r\n *\r\n * @since 4.3\r\n */\r\nlet ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {\r\n    /**\r\n     * Constructs a new instance of the {@link ErrorInfo} class with the\r\n     * specified detailed syntax error information.\r\n     *\r\n     * @param decision The decision number\r\n     * @param state The final simulator state reached during prediction\r\n     * prior to reaching the {@link ATNSimulator#ERROR} state\r\n     * @param input The input token stream\r\n     * @param startIndex The start index for the current prediction\r\n     * @param stopIndex The index at which the syntax error was identified\r\n     */\r\n    constructor(decision, state, input, startIndex, stopIndex) {\r\n        super(decision, state, input, startIndex, stopIndex, state.useContext);\r\n    }\r\n};\r\nErrorInfo = __decorate([\r\n    __param(1, Decorators_1.NotNull),\r\n    __param(2, Decorators_1.NotNull)\r\n], ErrorInfo);\r\nexports.ErrorInfo = ErrorInfo;\r\n//# sourceMappingURL=ErrorInfo.js.map","\"use strict\";\r\n/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// ConvertTo-TS run at 2016-10-04T11:26:30.6852565-07:00\r\nconst DecisionEventInfo_1 = require(\"./DecisionEventInfo\");\r\nconst Decorators_1 = require(\"../Decorators\");\r\n/**\r\n * This class represents profiling event information for tracking the lookahead\r\n * depth required in order to make a prediction.\r\n *\r\n * @since 4.3\r\n */\r\nlet LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {\r\n    /**\r\n     * Constructs a new instance of the {@link LookaheadEventInfo} class with\r\n     * the specified detailed lookahead information.\r\n     *\r\n     * @param decision The decision number\r\n     * @param state The final simulator state containing the necessary\r\n     * information to determine the result of a prediction, or `undefined` if\r\n     * the final state is not available\r\n     * @param input The input token stream\r\n     * @param startIndex The start index for the current prediction\r\n     * @param stopIndex The index at which the prediction was finally made\r\n     * @param fullCtx `true` if the current lookahead is part of an LL\r\n     * prediction; otherwise, `false` if the current lookahead is part of\r\n     * an SLL prediction\r\n     */\r\n    constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {\r\n        super(decision, state, input, startIndex, stopIndex, fullCtx);\r\n        this.predictedAlt = predictedAlt;\r\n    }\r\n};\r\nLookaheadEventInfo = __decorate([\r\n    __param(3, Decorators_1.NotNull)\r\n], LookaheadEventInfo);\r\nexports.LookaheadEventInfo = LookaheadEventInfo;\r\n//# sourceMappingURL=LookaheadEventInfo.js.map","\"use strict\";\r\n/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// ConvertTo-TS run at 2016-10-04T11:26:35.1914305-07:00\r\nconst DecisionEventInfo_1 = require(\"./DecisionEventInfo\");\r\nconst Decorators_1 = require(\"../Decorators\");\r\n/**\r\n * This class represents profiling event information for semantic predicate\r\n * evaluations which occur during prediction.\r\n *\r\n * @see ParserATNSimulator#evalSemanticContext\r\n *\r\n * @since 4.3\r\n */\r\nlet PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {\r\n    /**\r\n     * Constructs a new instance of the {@link PredicateEvalInfo} class with the\r\n     * specified detailed predicate evaluation information.\r\n     *\r\n     * @param state The simulator state\r\n     * @param decision The decision number\r\n     * @param input The input token stream\r\n     * @param startIndex The start index for the current prediction\r\n     * @param stopIndex The index at which the predicate evaluation was\r\n     * triggered. Note that the input stream may be reset to other positions for\r\n     * the actual evaluation of individual predicates.\r\n     * @param semctx The semantic context which was evaluated\r\n     * @param evalResult The results of evaluating the semantic context\r\n     * @param predictedAlt The alternative number for the decision which is\r\n     * guarded by the semantic context `semctx`. See {@link #predictedAlt}\r\n     * for more information.\r\n     *\r\n     * @see ParserATNSimulator#evalSemanticContext(SemanticContext, ParserRuleContext, int)\r\n     * @see SemanticContext#eval(Recognizer, RuleContext)\r\n     */\r\n    constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {\r\n        super(decision, state, input, startIndex, stopIndex, state.useContext);\r\n        this.semctx = semctx;\r\n        this.evalResult = evalResult;\r\n        this.predictedAlt = predictedAlt;\r\n    }\r\n};\r\nPredicateEvalInfo = __decorate([\r\n    __param(0, Decorators_1.NotNull),\r\n    __param(2, Decorators_1.NotNull),\r\n    __param(5, Decorators_1.NotNull)\r\n], PredicateEvalInfo);\r\nexports.PredicateEvalInfo = PredicateEvalInfo;\r\n//# sourceMappingURL=PredicateEvalInfo.js.map"],"names":["__decorate","$b97931ee5589be0e11a9b04c18348$exports","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","value","$fe43afe167589edf1a0bb37ac4be7118$exports","$fbfa1bf7ad6d90df6567e9e464fe9f$exports","Decorators_1","$dd406a9474b065d25da0a78b31931e3e$init","DecisionEventInfo","constructor","decision","state","input","startIndex","stopIndex","fullCtx","this","NotNull","prototype","$fbfa1bf7ad6d90df6567e9e464fe9f$export$DecisionEventInfo","AmbiguityInfo","ambigAlts","super","useContext","ambiguousAlternatives","$fe43afe167589edf1a0bb37ac4be7118$export$AmbiguityInfo","ATN_1","$c3ec778fdba7bb845ac51d1d6e9fa$init","ATNSimulator_1","$f0821b4c0e72e26f01b7f62d353706dc$init","$b24f23efa047a0ea38881f8f16b7d8ca$exports","ContextSensitivityInfo","$b24f23efa047a0ea38881f8f16b7d8ca$export$ContextSensitivityInfo","$e0ecc8a8d1502ae390c3086d0b49d024$exports","DecisionInfo","invocations","timeInPrediction","SLL_TotalLook","SLL_MinLook","SLL_MaxLook","LL_TotalLook","LL_MinLook","LL_MaxLook","contextSensitivities","errors","ambiguities","predicateEvals","SLL_ATNTransitions","SLL_DFATransitions","LL_Fallback","LL_ATNTransitions","LL_DFATransitions","toString","Override","$e0ecc8a8d1502ae390c3086d0b49d024$export$DecisionInfo","$af59d569cb99bfddb117c5e73db064d0$exports","ErrorInfo","$af59d569cb99bfddb117c5e73db064d0$export$ErrorInfo","$b719e3044eccddbfea5aa916cb64c676$exports","LookaheadEventInfo","predictedAlt","$b719e3044eccddbfea5aa916cb64c676$export$LookaheadEventInfo","ParserATNSimulator_1","$c45e2df38da0a14df5f7146362da69$init","$ea345300ca04e54ee85bb93d9b9$exports","PredicateEvalInfo","semctx","evalResult","$ea345300ca04e54ee85bb93d9b9$export$PredicateEvalInfo","SemanticContext_1","$fb06802959443d781c78c5c27b0d6d1b$init","SimulatorState_1","$ffa2d499933d88d91899be2fe7854e2e$init","ProfilingATNSimulator","ParserATNSimulator","parser","interpreter","atn","_startIndex","_sllStopIndex","_llStopIndex","currentDecision","conflictingAltResolvedBySLL","optimize_ll1","reportAmbiguities","numDecisions","decisionToState","decisions","push","adaptivePredict","outerContext","undefined","_input","index","currentState","ATN","INVALID_ALT_NUMBER","start","process","hrtime","alt","stop","nanoseconds","SLL_k","Math","min","SLL_MaxLookEvent","LL_k","LL_MaxLookEvent","getStartState","dfa","computeStartState","globalContext","computeReachSet","previous","t","contextCache","Error","reachState","getExistingTargetState","previousD","existingTargetState","SimulatorState","remainingOuterContext","ATNSimulator","ERROR","computeTargetState","s","remainingGlobalContext","targetState","evalSemanticContextImpl","pred","parserCallStack","result","SemanticContext","PrecedencePredicate","reportContextSensitivity","prediction","acceptState","reportAttemptingFullContext","conflictingAlts","conflictState","nextSetBit","s0","configs","getRepresentedAlternatives","reportAmbiguity","D","exact","getDecisionInfo","getCurrentState"],"version":3,"file":"ProfilingATNSimulator.9beb5167.js.map"}